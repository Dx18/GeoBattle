package geobattle.geobattle.game.buildings;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.utils.Predicate;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;

import geobattle.geobattle.actionresults.MatchBranch;
import geobattle.geobattle.game.gamestatediff.HangarDiff;
import geobattle.geobattle.game.gamestatediff.SectorDiff;
import geobattle.geobattle.game.research.ResearchInfo;
import geobattle.geobattle.game.units.Unit;
import geobattle.geobattle.map.BuildingTextures;
import geobattle.geobattle.map.GeoBattleMap;
import geobattle.geobattle.util.CastIterator;
import geobattle.geobattle.util.GeoBattleMath;
import geobattle.geobattle.util.IntRect;

// Sector
public final class Sector {
    // Base energy (which is generated by sector)
    public static final int BASE_ENERGY = 10;

    // Base health (min health)
    public static final int BASE_HEALTH = 100;

    // Size of sector
    public static final int SECTOR_SIZE = 41;

    // Size of beacon in the center of sector
    public static final int BEACON_SIZE = 3;

    // X coordinate of bottom-left corner of sector
    public final int x;

    // Y coordinate of bottom-left corner of sector
    public final int y;

    // ID of sector
    public final int sectorId;

    // Current health of sector
    private float health;

    // Max health of sector
    private float maxHealth;

    // Energy of sector
    private int energy;

    // Buildings in sector
    private ArrayList<Building> buildings;

    // Info about research
    private final ResearchInfo researchInfo;

    // Current state of sector
    private SectorState state;

    // Time of last update
    private double lastUpdateTime;

    // Comparator for buildings
    private final static Comparator<Building> buildingComparator = new Comparator<Building>() {
        @Override
        public int compare(Building building1, Building building2) {
            return building1.id - building2.id;
        }
    };

    // Creates sector
    public Sector(int x, int y, int sectorId, ResearchInfo researchInfo) {
        this.x = x;
        this.y = y;
        this.sectorId = sectorId;
        this.buildings = new ArrayList<Building>();
        updateConstParameters();
        this.health = maxHealth;
        this.researchInfo = researchInfo;
        setState(new SectorState.Normal());
    }

    // Updates `maxHealth` and `energy`
    private void updateConstParameters() {
        maxHealth = BASE_HEALTH;
        energy = BASE_ENERGY;
        for (Building building : buildings) {
            maxHealth += building.getBuildingType().healthBonus;
            energy += building.getBuildingType().getEnergyDelta(researchInfo);
        }
    }

    // Updates sector
    public void update(final float delta, double currentTime, final GeoBattleMap map) {
        if (state == null)
            return;

        state.match(
                new MatchBranch<SectorState.Normal>() {
                    @Override
                    public void onMatch(SectorState.Normal normal) {
                        updateNormal(delta, normal);
                    }
                },
                new MatchBranch<SectorState.Attacked>() {
                    @Override
                    public void onMatch(SectorState.Attacked attacked) {
                        updateAttacked(delta, attacked, map);
                    }
                }
        );

        this.lastUpdateTime = currentTime;
    }

    // Updates sector in case if it's in normal state
    private void updateNormal(float delta, SectorState.Normal normal) {
        if (energy < 0)
            return;

        Iterator<Turret> turrets = getTurrets();
        while (turrets.hasNext()) {
            Turret turret = turrets.next();
            turret.update(delta, null);
        }
    }

    // Updates sector in case if it's in attacked state
    private void updateAttacked(float delta, SectorState.Attacked attacked, GeoBattleMap map) {
        if (energy < 0)
            return;

        for (int group = 0; group < attacked.units.size(); group++) {
            if (attacked.units.get(group).getCount() == 0) {
                for (int attackedUnit = 0; attackedUnit < attacked.attackedUnits.length; attackedUnit++) {
                    if (attacked.attackedUnits[attackedUnit] != null && attacked.attackedUnits[attackedUnit].hangarId == attacked.units.get(group).hangarId)
                        attacked.attackedUnits[attackedUnit] = null;
                }
                attacked.units.remove(group);
            }
        }

        int index = 0;
        Iterator<Turret> turrets = getTurrets();
        while (turrets.hasNext()) {
            Turret turret = turrets.next();

            attacked.timeLeft[index] -= delta;
            if (attacked.units.size() != 0 && (attacked.timeLeft[index] <= 0 || attacked.attackedUnits[index] == null)) {
                int group = (int) (Math.random() * attacked.units.size());
                int unitIndex = (int) (Math.random() * attacked.units.get(group).getCount());

                int currentUnit = 0;
                Unit unit = null;
                Iterator<Unit> units = attacked.units.get(group).getAllUnits();
                while (units.hasNext()) {
                    if (currentUnit == unitIndex) {
                        unit = units.next();
                        break;
                    }
                    units.next();
                }
                attacked.attackedUnits[index] = unit;
                attacked.timeLeft[index] = Math.random() * 2 + 1;
            }

            turret.update(delta, attacked.attackedUnits[index]);

            index++;
        }
    }

    public void drawBeacon(Batch batch, GeoBattleMap map, BuildingTextures textures, Color color, boolean drawIcons) {
        if (drawIcons) {
            map.drawTexture(
                    batch,
                    x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                    y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                    Sector.BEACON_SIZE, Sector.BEACON_SIZE, 0,
                    textures.beaconIconTexture, color
            );
        } else {
            map.drawTexture(
                    batch,
                    x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                    y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                    Sector.BEACON_SIZE, Sector.BEACON_SIZE, 0.5f,
                    textures.beaconTexture, Color.WHITE
            );
            map.drawTexture(
                    batch,
                    x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                    y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                    Sector.BEACON_SIZE, Sector.BEACON_SIZE, 0.5f,
                    textures.beaconTeamColorTexture, color
            );
        }
    }

    public boolean containsPoint(int x, int y) {
        return GeoBattleMath.tileRectangleContains(
                this.x, this.y, Sector.SECTOR_SIZE, Sector.SECTOR_SIZE,
                x, y
        ) && !GeoBattleMath.tileRectangleContains(
                this.x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2 - 1,
                this.y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                Sector.BEACON_SIZE, Sector.BEACON_SIZE,
                x, y
        );
    }

    public boolean containsRect(IntRect rect) {
        return containsRect(rect.x, rect.y, rect.width, rect.height);
    }

    public boolean containsRect(int x, int y, int width, int height) {
        return GeoBattleMath.tileRectangleContains(
                this.x, this.y, Sector.SECTOR_SIZE, Sector.SECTOR_SIZE,
                x, y, width, height
        ) && !GeoBattleMath.tileRectanglesIntersect(
                this.x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                this.y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                Sector.BEACON_SIZE, Sector.BEACON_SIZE,
                x, y, width, height
        );
    }

    // Adds building. Keeps buildings sorted by ID
    public void addBuilding(Building building) {
        int index = Collections.binarySearch(buildings, building, buildingComparator);
        if (index >= 0)
            throw new IllegalArgumentException("Cannot add building with existing ID");

        buildings.add(-index - 1, building);
        health += building.getBuildingType().healthBonus;
        updateConstParameters();
    }

    // Removes building
    public void removeBuilding(Building building) {
        int removeIndex = Collections.binarySearch(buildings, building, buildingComparator);
        if (removeIndex < 0)
            throw new IllegalArgumentException("Cannot remove building with specified ID");

        buildings.remove(removeIndex);
        updateConstParameters();
    }

    // Returns building at coordinates
    public Building getBuilding(int x, int y) {
        for (Building building : buildings)
            if (GeoBattleMath.tileRectangleContains(
                    building.x, building.y, building.getSizeX(), building.getSizeY(),
                    x, y
            ))
                return building;

        return null;
    }

    // Finds building by id using binary search
    private static int findBuilding(ArrayList<Building> buildings, int id) {
        int left = 0;
        int right = buildings.size() - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (buildings.get(mid).id < id)
                left = mid + 1;
            else if (buildings.get(mid).id > id)
                right = mid - 1;
            else
                return mid;
        }

        return -left - 1;
    }

    // Returns building by ID
    public Building getBuilding(int id) {
        int index = findBuilding(buildings, id);

        if (index >= 0)
            return buildings.get(index);

        return null;
    }

    // Returns iterator over all buildings
    public Iterator<Building> getAllBuildings() {
        return buildings.iterator();
    }

    // Returns iterator over specified type of buildings
    public <T extends Building> Iterator<T> getBuildings(final Class<T> type) {
        final Predicate.PredicateIterator<Building> filtered = new Predicate.PredicateIterator<Building>(getAllBuildings(), new Predicate<Building>() {
            @Override
            public boolean evaluate(Building building) {
                return type.isInstance(building);
            }
        });

        return new CastIterator<Building, T>(filtered);
    }

    // Returns iterator over research centers
    public Iterator<ResearchCenter> getResearchCenters() {
        return getBuildings(ResearchCenter.class);
    }

    // Returns iterator over turrets
    public Iterator<Turret> getTurrets() {
        return getBuildings(Turret.class);
    }

    // Returns iterator over generators
    public Iterator<Generator> getGenerators() {
        return getBuildings(Generator.class);
    }

    // Returns iterator over mines
    public Iterator<Mine> getMines() {
        return getBuildings(Mine.class);
    }

    // Returns iterator over hangars
    public Iterator<Hangar> getHangars() {
        return getBuildings(Hangar.class);
    }

    // Clones sector
    public Sector clone() {
        Sector result = new Sector(x, y, sectorId, researchInfo.clone());

        for (Building building : buildings)
            result.addBuilding(building.clone());

        return result;
    }

    // Creates Sector from JSON
    public static Sector fromJson(JsonObject object, ResearchInfo researchInfo) {
        int x = object.getAsJsonPrimitive("x").getAsInt();
        int y = object.getAsJsonPrimitive("y").getAsInt();
        int sectorId = object.getAsJsonPrimitive("sectorId").getAsInt();

        Sector sector = new Sector(x, y, sectorId, researchInfo);

        JsonArray jsonBuildings = object.getAsJsonArray("buildings");
        for (JsonElement jsonBuilding : jsonBuildings)
            sector.addBuilding(Building.fromJson(jsonBuilding.getAsJsonObject()));

        return sector;
    }

    public float getHealth() {
        return health;
    }

    public void setHealth(float health) {
        this.health = MathUtils.clamp(health, 0, getMaxHealth());
    }

    public float getMaxHealth() {
        return maxHealth;
    }

    public int getEnergy() {
        return energy;
    }

    // Applies SectorDiff to sector
    public void applyDiff(SectorDiff diff) {
        for (Building removed : diff.removedBuildings)
            removeBuilding(removed);
        for (Building added : diff.addedBuildings)
            addBuilding(added);
        for (HangarDiff changed : diff.changedHangars)
            ((Hangar) getBuilding(changed.hangarId)).setUnits(changed.newUnits);
    }

    public SectorState getState() {
        return state;
    }

    public void setState(SectorState state) {
        this.state = state;
    }

    // Returns time of last update
    public double getLastUpdateTime() {
        return lastUpdateTime;
    }
}
