package geobattle.geobattle.game.buildings;

import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.Batch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.utils.ObjectIntMap;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;

import geobattle.geobattle.game.attacking.HealthInterpolation;
import geobattle.geobattle.game.gamestatediff.HangarDiff;
import geobattle.geobattle.game.gamestatediff.SectorDiff;
import geobattle.geobattle.game.research.ResearchInfo;
import geobattle.geobattle.game.tasks.TimedObjectQueue;
import geobattle.geobattle.game.units.Unit;
import geobattle.geobattle.game.units.UnitGroup;
import geobattle.geobattle.map.BuildingTextures;
import geobattle.geobattle.map.GeoBattleMap;
import geobattle.geobattle.util.GeoBattleMath;
import geobattle.geobattle.util.IntRect;
import geobattle.geobattle.util.ReadOnlyArrayList;

// Sector
public final class Sector {
    // Base energy (which is generated by sector)
    public static final int BASE_ENERGY = 10;

    // Base health (min health)
    public static final int BASE_HEALTH = 100;

    // Size of sector
    public static final int SECTOR_SIZE = 41;

    // Size of beacon in the center of sector
    public static final int BEACON_SIZE = 3;

    // X coordinate of bottom-left corner of sector
    public final int x;

    // Y coordinate of bottom-left corner of sector
    public final int y;

    // ID of sector
    public final int sectorId;

    // ID of player owning this sector
    public final int playerId;

    // Current health of sector
    private float health;

    // Max health of sector
    private float maxHealth;

    // Energy of sector
    private int energy;

    // Is sector blocked
    private boolean blocked;

    // Buildings in sector
    private ArrayList<Building> buildings;

    // Info about research
    private final ResearchInfo researchInfo;

    // Current health interpolation
    private HealthInterpolation healthInterpolation;

    // Units attacking current sector
    private final ArrayList<UnitGroup> attackingUnits;

    // Time of last update
    private double lastUpdateTime;

    // Next health interpolations
    public final TimedObjectQueue<HealthInterpolation> healthInterpolations;

    // Incoming units
    public final TimedObjectQueue<UnitGroup> incomingUnits;

    // Count of building
    private final ObjectIntMap<BuildingType> buildingCount;

    // Comparator for buildings
    private final static Comparator<Building> buildingComparator = new Comparator<Building>() {
        @Override
        public int compare(Building building1, Building building2) {
            return building1.id - building2.id;
        }
    };

    // Creates sector
    public Sector(int x, int y, int sectorId, int playerId, ResearchInfo researchInfo) {
        this.x = x;
        this.y = y;
        this.sectorId = sectorId;
        this.playerId = playerId;
        this.buildings = new ArrayList<Building>();
        updateConstParameters();
        this.health = maxHealth;
        this.researchInfo = researchInfo;
        attackingUnits = new ArrayList<UnitGroup>();
        healthInterpolations = new TimedObjectQueue<HealthInterpolation>();
        incomingUnits = new TimedObjectQueue<UnitGroup>();
        this.buildingCount = new ObjectIntMap<BuildingType>();
    }

    // Updates `maxHealth` and `energy`
    private void updateConstParameters() {
        maxHealth = BASE_HEALTH;
        energy = BASE_ENERGY;
        for (Building building : buildings) {
            maxHealth += building.getBuildingType().healthBonus;
            energy += building.getBuildingType().getEnergyDelta(researchInfo);
        }
    }

    // Updates sector
    public void update(final float delta, double currentTime, final GeoBattleMap map) {
        attackingUnits.addAll(incomingUnits.getObjects(currentTime));

        ArrayList<HealthInterpolation> newHealth = healthInterpolations.getObjects(currentTime);
        if (newHealth.size() > 0)
            healthInterpolation = newHealth.get(newHealth.size() - 1);

        if (healthInterpolation != null)
            setHealth((float) healthInterpolation.getHealth(currentTime));

        if (energy < 0)
            return;

        for (int groupIndex = 0; groupIndex < attackingUnits.size(); ) {
            UnitGroup group = attackingUnits.get(groupIndex);
            if (group.getCount() == 0) {
                for (int buildingIndex = 0; buildingIndex < buildings.size(); buildingIndex++) {
                    Building building = buildings.get(buildingIndex);
                    if (building instanceof Turret) {
                        Turret turret = (Turret) building;
                        if (turret.getTarget() != null && turret.getTarget().hangarId == group.hangarId)
                            turret.setTarget(null);
                    }
                }
                attackingUnits.remove(groupIndex);
            } else
                groupIndex++;
        }

        for (int buildingIndex = 0; buildingIndex < buildings.size(); buildingIndex++) {
            Building building = buildings.get(buildingIndex);
            if (!(building instanceof Turret))
                continue;
            Turret turret = (Turret) building;

            if (attackingUnits.size() != 0 && (turret.getTargetTime() <= 0 || turret.getTarget() == null)) {
                int group = (int) (Math.random() * attackingUnits.size());
                int unitIndex = (int) (Math.random() * attackingUnits.get(group).getCount());

                int currentUnit = 0;
                Unit unit = null;
                Iterator<Unit> units = attackingUnits.get(group).getAllUnits();
                while (units.hasNext()) {
                    if (currentUnit == unitIndex) {
                        unit = units.next();
                        break;
                    }
                    units.next();
                }
                turret.setTarget(unit);
                turret.setTargetTime(Math.random() * 2 + 1);
            }

            turret.update(delta, map);
        }

        this.lastUpdateTime = currentTime;
    }

    public void drawBeacon(Batch batch, GeoBattleMap map, BuildingTextures textures, Color color, boolean drawIcons) {
        if (drawIcons) {
            map.drawTexture(
                    batch,
                    x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                    y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                    Sector.BEACON_SIZE, Sector.BEACON_SIZE,
                    textures.beaconIconTexture, color
            );
        } else {
            map.drawTexture(
                    batch,
                    x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2 - 0.5,
                    y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2 - 0.5,
                    Sector.BEACON_SIZE + 1, Sector.BEACON_SIZE + 1,
                    textures.beaconTexture, Color.WHITE
            );
            map.drawTexture(
                    batch,
                    x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2 - 0.5,
                    y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2 - 0.5,
                    Sector.BEACON_SIZE + 1, Sector.BEACON_SIZE + 1,
                    textures.beaconTeamColorTexture, color
            );
        }
    }

    public boolean containsPoint(int x, int y) {
        return GeoBattleMath.tileRectangleContains(
                this.x, this.y, Sector.SECTOR_SIZE, Sector.SECTOR_SIZE,
                x, y
        ) && !GeoBattleMath.tileRectangleContains(
                this.x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2 - 1,
                this.y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                Sector.BEACON_SIZE, Sector.BEACON_SIZE,
                x, y
        );
    }

    public boolean containsRect(IntRect rect) {
        return containsRect(rect.x, rect.y, rect.width, rect.height);
    }

    public boolean containsRect(int x, int y, int width, int height) {
        return GeoBattleMath.tileRectangleContains(
                this.x, this.y, Sector.SECTOR_SIZE, Sector.SECTOR_SIZE,
                x, y, width, height
        ) && !GeoBattleMath.tileRectanglesIntersect(
                this.x + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                this.y + Sector.SECTOR_SIZE / 2 - Sector.BEACON_SIZE / 2,
                Sector.BEACON_SIZE, Sector.BEACON_SIZE,
                x, y, width, height
        );
    }

    // Adds building. Keeps buildings sorted by ID
    public void addBuilding(Building building) {
        int index = Collections.binarySearch(buildings, building, buildingComparator);
        if (index >= 0)
            throw new IllegalArgumentException("Cannot add building with existing ID");

        buildings.add(-index - 1, building);
        buildingCount.getAndIncrement(building.getBuildingType(), 0, 1);
        health += building.getBuildingType().healthBonus;
        updateConstParameters();
    }

    // Removes building
    public void removeBuilding(Building building) {
        int removeIndex = Collections.binarySearch(buildings, building, buildingComparator);
        if (removeIndex < 0)
            throw new IllegalArgumentException("Cannot remove building with specified ID");

        buildings.remove(removeIndex);
        buildingCount.getAndIncrement(building.getBuildingType(), 0, -1);
        updateConstParameters();
    }

    // Returns building at coordinates
    public Building getBuilding(int x, int y) {
        for (Building building : buildings)
            if (GeoBattleMath.tileRectangleContains(
                    building.x, building.y, building.getSizeX(), building.getSizeY(),
                    x, y
            ))
                return building;

        return null;
    }

    // Finds building by id using binary search
    private static int findBuilding(ArrayList<Building> buildings, int id) {
        int left = 0;
        int right = buildings.size() - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (buildings.get(mid).id < id)
                left = mid + 1;
            else if (buildings.get(mid).id > id)
                right = mid - 1;
            else
                return mid;
        }

        return -left - 1;
    }

    // Returns building by ID
    public Building getBuilding(int id) {
        int index = findBuilding(buildings, id);

        if (index >= 0)
            return buildings.get(index);

        return null;
    }

    // Returns read-only list of all buildings
    public ReadOnlyArrayList<Building> getAllBuildings() {
        return new ReadOnlyArrayList<Building>(buildings);
    }

    // Returns count of buildings of specific type
    public int getCount(BuildingType buildingType) {
        return buildingCount.get(buildingType, 0);
    }

    // Creates Sector from JSON
    public static Sector fromJson(JsonObject object, int playerId, ResearchInfo researchInfo) {
        int x = object.getAsJsonPrimitive("x").getAsInt();
        int y = object.getAsJsonPrimitive("y").getAsInt();
        int sectorId = object.getAsJsonPrimitive("sectorId").getAsInt();

        Sector sector = new Sector(x, y, sectorId, playerId, researchInfo);

        JsonArray jsonBuildings = object.getAsJsonArray("buildings");
        for (JsonElement jsonBuilding : jsonBuildings)
            sector.addBuilding(Building.fromJson(jsonBuilding.getAsJsonObject()));

        return sector;
    }

    public float getHealth() {
        return health;
    }

    public void setHealth(float health) {
        this.health = MathUtils.clamp(health, 0, getMaxHealth());
    }

    public float getMaxHealth() {
        return maxHealth;
    }

    public int getEnergy() {
        return energy;
    }

    // Sets block state of sector
    public void setBlocked(boolean blocked) {
        this.blocked = blocked;
    }

    // Returns true if sector is blocked
    public boolean isBlocked() {
        return blocked;
    }

    // Applies SectorDiff to sector
    public void applyDiff(SectorDiff diff) {
        for (Building removed : diff.removedBuildings)
            removeBuilding(removed);
        for (Building added : diff.addedBuildings)
            addBuilding(added);
        for (HangarDiff changed : diff.changedHangars)
            ((Hangar) getBuilding(changed.hangarId)).setUnits(changed.newUnits);
    }

    // Returns time of last update
    public double getLastUpdateTime() {
        return lastUpdateTime;
    }
}
